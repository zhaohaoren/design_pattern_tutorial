#【设计模式】状态模式

本文主要介绍状态模式的概念以及用法。

## 模式背景

生活中很多东西都会有不同的状态，并且在不同的状态下会有着不同的行为。比如，水可以分为固态，液态，汽态，在每一种态下面他的表现形式也不同。一个个人银行的账户，可能依据存钱或者欠钱的额度在银行中标记为不同状态，VIP可以每日转额度10w，欠款用户账户被冻结等。

这些都会对应着一些系统设计的问题：如何才能在系统中更好的处理这些状态的转换？如果我们使用`if-else`的话，状态如果太多，以及添加和删除状态都会存在问题，要么**类的职责太重`if-else`逻辑太多**，要么**添加移除状态会很麻烦**。这就是状态模式要解决的问题。

## 定义&概念

状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来就好像修改了它的类一样。是一种对象行为型模式。

## 原理

上面背景中，我们讨论的问题其实是一个问题。而状态模式其实要解决2个问题：

1. 如何让客户端进行一致的处理，让客户端不需要去处理状态的转换，状态的转换对客户端应该是透明的。
2. 状态如何更好的进行转换？

针对问题1，我们提供了一个环境类，

针对问题2，是我们状态模式核心。这个问题也分2步骤：1. 想要状态好扩展该怎么办？这个我们之前也看的多了——抽象呗！所以状态模式引入了抽象状态类和具体状态类。扩展的问题解决了，该**如何进行转换呢？状态模式有2种方式**：

1. **每个具体状态自己做check以及状态的扭转**，这样就需要获取到环境类的引用，我们可以状态类内部持有（推荐），或者参数传递的方式。（这种其实有点责任链的思想在里面了）
2. 由**环境类来控制转换**，环境类里面进行`if-else`判断，但是这种有一定缺陷，就是扩充状态类的时候，需要修改环境类，违背了开闭原则。

**组成要素**

- 环境类
  - 又叫上下文类，内部引用了一个状态类的实例。主要就是这个类主要负责环境，而状态切割到各个状态类中去，实现解耦。它负责状态之间的转换。
  - 环境类对象其实就是那些存在状态转换的对象，只是他的状态属性被隔离出去了，只引用一个抽象状态。状态+其他属性=这个对象。
- 抽象状态类
  - 一个接口，封装了一个特定状态相关的行为。如果很多行为是共享的，那么也可以定位抽象类，将公共方法提取到抽象类方法中。
- 具体状态类
  - 具体的状态类，一个具体状态类代表环境类里面某个环境的的一种状态。所以不同的状态类应该有不同的行为。这里面就是具体行为的逻辑。

### 共享状态

当多个环境类需要共享一个或者多个状态的时候（每个环境类其实对应一个具体的状态对象，多个环境类需要共享状态的意思就是说，这一组环境类的对象，当其中一个环境对象状态变化的时候，该环境类所有的对象的状态都要变化。书里面的例子：灯有开状态和关状态，开关就是对应的环境类，我们有2个开关，控制同一个灯，就属于共享状态。），可以将该状态定义为静态的引用。这样这个状态就属于这个类，而不是某个具体的环境对象。

## UML

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47e7a724b2ee4ffcb6e4aed9e5e0b10a~tplv-k3u1fbpfcp-zoom-1.image)

## 实现

这里实现案例是基于环境类的状态转换。

环境类

```java
public class WaterContext {
    /**
     * 引用该Context所有可能的State
     */
    private WaterState state;

    public WaterState getState() {
        return state;
    }

    /**
     * 使用环境类来完成状态的转换，还可以使用状态实现类的方式。具体后面补充
     *
     * @param value 环境切换的判断依据
     */
    public void setWaterState(int value) {
        if (value == 0) {
            state = new IceWaterState();
        } else if (value == 1) {
            state = new WarmWaterState();
        } else if (value == 2) {
            state = new HotWaterState();
        }
    }
}
```

状态抽象

```java
public interface WaterState {
    void showState();
}
```

具体状态实现

```java
public class IceWaterState implements WaterState {
    @Override
    public void showState() {
        System.out.println("i am ice");
    }
}
//....WarmWaterState...HotWaterState
```

客户端

```java
public static void main(String[] args) {
    WaterContext context = new WaterContext();
    context.setWaterState(0);
    context.getState().showState();
    context.setWaterState(1);
    context.getState().showState();
    context.setWaterState(2);
    context.getState().showState();
}
```
## 优缺点

### 优点

- 可以减少系统中`if-else`分支太多的情况。
- 状态类方便管理和维护，状态很清晰，方便进行管理。

### 缺点

- 会增加系统类和对象个数，增大系统开销。
- 会增加系统设计难度，可能存在某些情况下，使用状态模式会让编码更加复杂。
- 状态类的转换，对开闭原则支持不太好。

## 使用场景

- 系统中对象行为随状态改变而改变的场景。
- 系统中如果有大量的条件、分支语句，可以考虑使用状态模式代替（阿里巴巴java开发手册也提到过，超过三层的if-else分支时候，就可以考虑了）。

## 总结

要使用状态模式，抓住2个主要矛盾就行了：系统某个对象存在多个状态，每个状态具有不同的行为。确定好了使用状态模式后，我们就要抓住了，该对象会触发状态变化的那些方法。然后就是环境类，抽象状态，具体状态的实现了。

# 附

相关代码：https://github.com/zhaohaoren/design_pattern_tutorial

如有代码和文章问题，还请指正！感谢！